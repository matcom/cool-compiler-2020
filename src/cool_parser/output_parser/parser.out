Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> class_list
Rule 2     epsilon -> <empty>
Rule 3     class_list -> def_class class_list
Rule 4     class_list -> def_class
Rule 5     class_list -> error class_list
Rule 6     def_class -> class type ocur feature_list ccur semi
Rule 7     def_class -> class type inherits type ocur feature_list ccur semi
Rule 8     def_class -> class error ocur feature_list ccur semi
Rule 9     def_class -> class error inherits type ocur feature_list ccur semi
Rule 10    def_class -> class error inherits error ocur feature_list ccur semi
Rule 11    def_class -> class type inherits error ocur feature_list ccur semi
Rule 12    feature_list -> epsilon
Rule 13    feature_list -> def_attr semi feature_list
Rule 14    feature_list -> def_func semi feature_list
Rule 15    feature_list -> error feature_list
Rule 16    def_attr -> id colon type
Rule 17    def_attr -> id colon type larrow expr
Rule 18    def_attr -> error colon type
Rule 19    def_attr -> id colon error
Rule 20    def_attr -> error colon type larrow expr
Rule 21    def_attr -> id colon error larrow expr
Rule 22    def_attr -> id colon type larrow error
Rule 23    def_func -> id opar formals cpar colon type ocur expr ccur
Rule 24    def_func -> error opar formals cpar colon type ocur expr ccur
Rule 25    def_func -> id opar error cpar colon type ocur expr ccur
Rule 26    def_func -> id opar formals cpar colon error ocur expr ccur
Rule 27    def_func -> id opar formals cpar colon type ocur error ccur
Rule 28    formals -> param_list
Rule 29    formals -> param_list_empty
Rule 30    param_list -> param
Rule 31    param_list -> param comma param_list
Rule 32    param_list -> error param_list
Rule 33    param_list_empty -> epsilon
Rule 34    param -> id colon type
Rule 35    expr -> let let_list in expr
Rule 36    expr -> let error in expr
Rule 37    expr -> let let_list in error
Rule 38    expr -> case expr of cases_list esac
Rule 39    expr -> case error of cases_list esac
Rule 40    expr -> case expr of error esac
Rule 41    expr -> if expr then expr else expr fi
Rule 42    expr -> if error then expr else expr fi
Rule 43    expr -> if expr then error else expr fi
Rule 44    expr -> if expr then expr else error fi
Rule 45    expr -> while expr loop expr pool
Rule 46    expr -> while error loop expr pool
Rule 47    expr -> while expr loop error pool
Rule 48    expr -> while expr loop expr error
Rule 49    expr -> arith
Rule 50    let_list -> let_assign
Rule 51    let_list -> let_assign comma let_list
Rule 52    let_list -> error let_list
Rule 53    let_assign -> param larrow expr
Rule 54    let_assign -> param
Rule 55    cases_list -> casep semi
Rule 56    cases_list -> casep semi cases_list
Rule 57    cases_list -> error cases_list
Rule 58    casep -> id colon type rarrow expr
Rule 59    arith -> id larrow expr
Rule 60    arith -> not comp
Rule 61    arith -> comp
Rule 62    comp -> comp less op
Rule 63    comp -> comp lesseq op
Rule 64    comp -> comp equal op
Rule 65    comp -> op
Rule 66    op -> op plus term
Rule 67    op -> op minus term
Rule 68    op -> term
Rule 69    term -> term star base_call
Rule 70    term -> term div base_call
Rule 71    term -> isvoid base_call
Rule 72    term -> nox base_call
Rule 73    term -> base_call
Rule 74    base_call -> factor arroba type dot func_call
Rule 75    base_call -> factor
Rule 76    factor -> atom
Rule 77    factor -> opar expr cpar
Rule 78    factor -> factor dot func_call
Rule 79    factor -> func_call
Rule 80    atom -> num
Rule 81    atom -> id
Rule 82    atom -> new type
Rule 83    atom -> new error
Rule 84    atom -> ocur block ccur
Rule 85    atom -> true
Rule 86    atom -> false
Rule 87    atom -> string
Rule 88    block -> expr semi
Rule 89    block -> expr semi block
Rule 90    block -> error block
Rule 91    block -> error
Rule 92    func_call -> id opar args cpar
Rule 93    args -> arg_list
Rule 94    args -> arg_list_empty
Rule 95    arg_list -> expr
Rule 96    arg_list -> expr comma arg_list
Rule 97    arg_list -> error arg_list
Rule 98    arg_list_empty -> epsilon

Terminals, with rules where they appear

arroba               : 74
case                 : 38 39 40
ccur                 : 6 7 8 9 10 11 23 24 25 26 27 84
class                : 6 7 8 9 10 11
colon                : 16 17 18 19 20 21 22 23 24 25 26 27 34 58
comma                : 31 51 96
cpar                 : 23 24 25 26 27 77 92
div                  : 70
dot                  : 74 78
else                 : 41 42 43 44
equal                : 64
error                : 5 8 9 10 10 11 15 18 19 20 21 22 24 25 26 27 32 36 37 39 40 42 43 44 46 47 48 52 57 83 90 91 97
esac                 : 38 39 40
false                : 86
fi                   : 41 42 43 44
id                   : 16 17 19 21 22 23 25 26 27 34 58 59 81 92
if                   : 41 42 43 44
in                   : 35 36 37
inherits             : 7 9 10 11
isvoid               : 71
larrow               : 17 20 21 22 53 59
less                 : 62
lesseq               : 63
let                  : 35 36 37
loop                 : 45 46 47 48
minus                : 67
new                  : 82 83
not                  : 60
nox                  : 72
num                  : 80
ocur                 : 6 7 8 9 10 11 23 24 25 26 27 84
of                   : 38 39 40
opar                 : 23 24 25 26 27 77 92
plus                 : 66
pool                 : 45 46 47
rarrow               : 58
semi                 : 6 7 8 9 10 11 13 14 55 56 88 89
star                 : 69
string               : 87
then                 : 41 42 43 44
true                 : 85
type                 : 6 7 7 9 11 16 17 18 20 22 23 24 25 27 34 58 74 82
while                : 45 46 47 48

Nonterminals, with rules where they appear

arg_list             : 93 96 97
arg_list_empty       : 94
args                 : 92
arith                : 49
atom                 : 76
base_call            : 69 70 71 72 73
block                : 84 89 90
casep                : 55 56
cases_list           : 38 39 56 57
class_list           : 1 3 5
comp                 : 60 61 62 63 64
def_attr             : 13
def_class            : 3 4
def_func             : 14
epsilon              : 12 33 98
expr                 : 17 20 21 23 24 25 26 35 36 38 40 41 41 41 42 42 43 43 44 44 45 45 46 47 48 48 53 58 59 77 88 89 95 96
factor               : 74 75 78
feature_list         : 6 7 8 9 10 11 13 14 15
formals              : 23 24 26 27
func_call            : 74 78 79
let_assign           : 50 51
let_list             : 35 37 51 52
op                   : 62 63 64 65 66 67
param                : 30 31 53 54
param_list           : 28 31 32
param_list_empty     : 29
program              : 0
term                 : 66 67 68 69 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_list
    (3) class_list -> . def_class class_list
    (4) class_list -> . def_class
    (5) class_list -> . error class_list
    (6) def_class -> . class type ocur feature_list ccur semi
    (7) def_class -> . class type inherits type ocur feature_list ccur semi
    (8) def_class -> . class error ocur feature_list ccur semi
    (9) def_class -> . class error inherits type ocur feature_list ccur semi
    (10) def_class -> . class error inherits error ocur feature_list ccur semi
    (11) def_class -> . class type inherits error ocur feature_list ccur semi

    error           shift and go to state 4
    class           shift and go to state 5

    program                        shift and go to state 1
    class_list                     shift and go to state 2
    def_class                      shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class_list .

    $end            reduce using rule 1 (program -> class_list .)


state 3

    (3) class_list -> def_class . class_list
    (4) class_list -> def_class .
    (3) class_list -> . def_class class_list
    (4) class_list -> . def_class
    (5) class_list -> . error class_list
    (6) def_class -> . class type ocur feature_list ccur semi
    (7) def_class -> . class type inherits type ocur feature_list ccur semi
    (8) def_class -> . class error ocur feature_list ccur semi
    (9) def_class -> . class error inherits type ocur feature_list ccur semi
    (10) def_class -> . class error inherits error ocur feature_list ccur semi
    (11) def_class -> . class type inherits error ocur feature_list ccur semi

    $end            reduce using rule 4 (class_list -> def_class .)
    error           shift and go to state 4
    class           shift and go to state 5

    def_class                      shift and go to state 3
    class_list                     shift and go to state 6

state 4

    (5) class_list -> error . class_list
    (3) class_list -> . def_class class_list
    (4) class_list -> . def_class
    (5) class_list -> . error class_list
    (6) def_class -> . class type ocur feature_list ccur semi
    (7) def_class -> . class type inherits type ocur feature_list ccur semi
    (8) def_class -> . class error ocur feature_list ccur semi
    (9) def_class -> . class error inherits type ocur feature_list ccur semi
    (10) def_class -> . class error inherits error ocur feature_list ccur semi
    (11) def_class -> . class type inherits error ocur feature_list ccur semi

    error           shift and go to state 4
    class           shift and go to state 5

    class_list                     shift and go to state 7
    def_class                      shift and go to state 3

state 5

    (6) def_class -> class . type ocur feature_list ccur semi
    (7) def_class -> class . type inherits type ocur feature_list ccur semi
    (8) def_class -> class . error ocur feature_list ccur semi
    (9) def_class -> class . error inherits type ocur feature_list ccur semi
    (10) def_class -> class . error inherits error ocur feature_list ccur semi
    (11) def_class -> class . type inherits error ocur feature_list ccur semi

    type            shift and go to state 8
    error           shift and go to state 9


state 6

    (3) class_list -> def_class class_list .

    $end            reduce using rule 3 (class_list -> def_class class_list .)


state 7

    (5) class_list -> error class_list .

    $end            reduce using rule 5 (class_list -> error class_list .)


state 8

    (6) def_class -> class type . ocur feature_list ccur semi
    (7) def_class -> class type . inherits type ocur feature_list ccur semi
    (11) def_class -> class type . inherits error ocur feature_list ccur semi

    ocur            shift and go to state 10
    inherits        shift and go to state 11


state 9

    (8) def_class -> class error . ocur feature_list ccur semi
    (9) def_class -> class error . inherits type ocur feature_list ccur semi
    (10) def_class -> class error . inherits error ocur feature_list ccur semi

    ocur            shift and go to state 12
    inherits        shift and go to state 13


state 10

    (6) def_class -> class type ocur . feature_list ccur semi
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 14
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 11

    (7) def_class -> class type inherits . type ocur feature_list ccur semi
    (11) def_class -> class type inherits . error ocur feature_list ccur semi

    type            shift and go to state 20
    error           shift and go to state 21


state 12

    (8) def_class -> class error ocur . feature_list ccur semi
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 22
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 13

    (9) def_class -> class error inherits . type ocur feature_list ccur semi
    (10) def_class -> class error inherits . error ocur feature_list ccur semi

    type            shift and go to state 24
    error           shift and go to state 23


state 14

    (6) def_class -> class type ocur feature_list . ccur semi

    ccur            shift and go to state 25


state 15

    (12) feature_list -> epsilon .

    ccur            reduce using rule 12 (feature_list -> epsilon .)


state 16

    (13) feature_list -> def_attr . semi feature_list

    semi            shift and go to state 26


state 17

    (14) feature_list -> def_func . semi feature_list

    semi            shift and go to state 27


state 18

    (15) feature_list -> error . feature_list
    (18) def_attr -> error . colon type
    (20) def_attr -> error . colon type larrow expr
    (24) def_func -> error . opar formals cpar colon type ocur expr ccur
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    colon           shift and go to state 29
    opar            shift and go to state 30
    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 28
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 19

    (16) def_attr -> id . colon type
    (17) def_attr -> id . colon type larrow expr
    (19) def_attr -> id . colon error
    (21) def_attr -> id . colon error larrow expr
    (22) def_attr -> id . colon type larrow error
    (23) def_func -> id . opar formals cpar colon type ocur expr ccur
    (25) def_func -> id . opar error cpar colon type ocur expr ccur
    (26) def_func -> id . opar formals cpar colon error ocur expr ccur
    (27) def_func -> id . opar formals cpar colon type ocur error ccur

    colon           shift and go to state 31
    opar            shift and go to state 32


state 20

    (7) def_class -> class type inherits type . ocur feature_list ccur semi

    ocur            shift and go to state 33


state 21

    (11) def_class -> class type inherits error . ocur feature_list ccur semi

    ocur            shift and go to state 34


state 22

    (8) def_class -> class error ocur feature_list . ccur semi

    ccur            shift and go to state 35


state 23

    (10) def_class -> class error inherits error . ocur feature_list ccur semi

    ocur            shift and go to state 36


state 24

    (9) def_class -> class error inherits type . ocur feature_list ccur semi

    ocur            shift and go to state 37


state 25

    (6) def_class -> class type ocur feature_list ccur . semi

    semi            shift and go to state 38


state 26

    (13) feature_list -> def_attr semi . feature_list
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    def_attr                       shift and go to state 16
    feature_list                   shift and go to state 39
    epsilon                        shift and go to state 15
    def_func                       shift and go to state 17

state 27

    (14) feature_list -> def_func semi . feature_list
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    def_func                       shift and go to state 17
    feature_list                   shift and go to state 40
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16

state 28

    (15) feature_list -> error feature_list .

    ccur            reduce using rule 15 (feature_list -> error feature_list .)


state 29

    (18) def_attr -> error colon . type
    (20) def_attr -> error colon . type larrow expr

    type            shift and go to state 41


state 30

    (24) def_func -> error opar . formals cpar colon type ocur expr ccur
    (28) formals -> . param_list
    (29) formals -> . param_list_empty
    (30) param_list -> . param
    (31) param_list -> . param comma param_list
    (32) param_list -> . error param_list
    (33) param_list_empty -> . epsilon
    (34) param -> . id colon type
    (2) epsilon -> .

    error           shift and go to state 42
    id              shift and go to state 48
    cpar            reduce using rule 2 (epsilon -> .)

    formals                        shift and go to state 43
    param_list                     shift and go to state 44
    param_list_empty               shift and go to state 45
    param                          shift and go to state 46
    epsilon                        shift and go to state 47

state 31

    (16) def_attr -> id colon . type
    (17) def_attr -> id colon . type larrow expr
    (19) def_attr -> id colon . error
    (21) def_attr -> id colon . error larrow expr
    (22) def_attr -> id colon . type larrow error

    type            shift and go to state 49
    error           shift and go to state 50


state 32

    (23) def_func -> id opar . formals cpar colon type ocur expr ccur
    (25) def_func -> id opar . error cpar colon type ocur expr ccur
    (26) def_func -> id opar . formals cpar colon error ocur expr ccur
    (27) def_func -> id opar . formals cpar colon type ocur error ccur
    (28) formals -> . param_list
    (29) formals -> . param_list_empty
    (30) param_list -> . param
    (31) param_list -> . param comma param_list
    (32) param_list -> . error param_list
    (33) param_list_empty -> . epsilon
    (34) param -> . id colon type
    (2) epsilon -> .

    error           shift and go to state 52
    id              shift and go to state 48
    cpar            reduce using rule 2 (epsilon -> .)

    formals                        shift and go to state 51
    param_list                     shift and go to state 44
    param_list_empty               shift and go to state 45
    param                          shift and go to state 46
    epsilon                        shift and go to state 47

state 33

    (7) def_class -> class type inherits type ocur . feature_list ccur semi
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 53
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 34

    (11) def_class -> class type inherits error ocur . feature_list ccur semi
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 54
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 35

    (8) def_class -> class error ocur feature_list ccur . semi

    semi            shift and go to state 55


state 36

    (10) def_class -> class error inherits error ocur . feature_list ccur semi
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 56
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 37

    (9) def_class -> class error inherits type ocur . feature_list ccur semi
    (12) feature_list -> . epsilon
    (13) feature_list -> . def_attr semi feature_list
    (14) feature_list -> . def_func semi feature_list
    (15) feature_list -> . error feature_list
    (2) epsilon -> .
    (16) def_attr -> . id colon type
    (17) def_attr -> . id colon type larrow expr
    (18) def_attr -> . error colon type
    (19) def_attr -> . id colon error
    (20) def_attr -> . error colon type larrow expr
    (21) def_attr -> . id colon error larrow expr
    (22) def_attr -> . id colon type larrow error
    (23) def_func -> . id opar formals cpar colon type ocur expr ccur
    (24) def_func -> . error opar formals cpar colon type ocur expr ccur
    (25) def_func -> . id opar error cpar colon type ocur expr ccur
    (26) def_func -> . id opar formals cpar colon error ocur expr ccur
    (27) def_func -> . id opar formals cpar colon type ocur error ccur

    error           shift and go to state 18
    ccur            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 19

    feature_list                   shift and go to state 57
    epsilon                        shift and go to state 15
    def_attr                       shift and go to state 16
    def_func                       shift and go to state 17

state 38

    (6) def_class -> class type ocur feature_list ccur semi .

    error           reduce using rule 6 (def_class -> class type ocur feature_list ccur semi .)
    class           reduce using rule 6 (def_class -> class type ocur feature_list ccur semi .)
    $end            reduce using rule 6 (def_class -> class type ocur feature_list ccur semi .)


state 39

    (13) feature_list -> def_attr semi feature_list .

    ccur            reduce using rule 13 (feature_list -> def_attr semi feature_list .)


state 40

    (14) feature_list -> def_func semi feature_list .

    ccur            reduce using rule 14 (feature_list -> def_func semi feature_list .)


state 41

    (18) def_attr -> error colon type .
    (20) def_attr -> error colon type . larrow expr

    semi            reduce using rule 18 (def_attr -> error colon type .)
    larrow          shift and go to state 58


state 42

    (32) param_list -> error . param_list
    (30) param_list -> . param
    (31) param_list -> . param comma param_list
    (32) param_list -> . error param_list
    (34) param -> . id colon type

    error           shift and go to state 42
    id              shift and go to state 48

    param_list                     shift and go to state 59
    param                          shift and go to state 46

state 43

    (24) def_func -> error opar formals . cpar colon type ocur expr ccur

    cpar            shift and go to state 60


state 44

    (28) formals -> param_list .

    cpar            reduce using rule 28 (formals -> param_list .)


state 45

    (29) formals -> param_list_empty .

    cpar            reduce using rule 29 (formals -> param_list_empty .)


state 46

    (30) param_list -> param .
    (31) param_list -> param . comma param_list

    cpar            reduce using rule 30 (param_list -> param .)
    comma           shift and go to state 61


state 47

    (33) param_list_empty -> epsilon .

    cpar            reduce using rule 33 (param_list_empty -> epsilon .)


state 48

    (34) param -> id . colon type

    colon           shift and go to state 62


state 49

    (16) def_attr -> id colon type .
    (17) def_attr -> id colon type . larrow expr
    (22) def_attr -> id colon type . larrow error

    semi            reduce using rule 16 (def_attr -> id colon type .)
    larrow          shift and go to state 63


state 50

    (19) def_attr -> id colon error .
    (21) def_attr -> id colon error . larrow expr

    semi            reduce using rule 19 (def_attr -> id colon error .)
    larrow          shift and go to state 64


state 51

    (23) def_func -> id opar formals . cpar colon type ocur expr ccur
    (26) def_func -> id opar formals . cpar colon error ocur expr ccur
    (27) def_func -> id opar formals . cpar colon type ocur error ccur

    cpar            shift and go to state 65


state 52

    (25) def_func -> id opar error . cpar colon type ocur expr ccur
    (32) param_list -> error . param_list
    (30) param_list -> . param
    (31) param_list -> . param comma param_list
    (32) param_list -> . error param_list
    (34) param -> . id colon type

    cpar            shift and go to state 66
    error           shift and go to state 42
    id              shift and go to state 48

    param_list                     shift and go to state 59
    param                          shift and go to state 46

state 53

    (7) def_class -> class type inherits type ocur feature_list . ccur semi

    ccur            shift and go to state 67


state 54

    (11) def_class -> class type inherits error ocur feature_list . ccur semi

    ccur            shift and go to state 68


state 55

    (8) def_class -> class error ocur feature_list ccur semi .

    error           reduce using rule 8 (def_class -> class error ocur feature_list ccur semi .)
    class           reduce using rule 8 (def_class -> class error ocur feature_list ccur semi .)
    $end            reduce using rule 8 (def_class -> class error ocur feature_list ccur semi .)


state 56

    (10) def_class -> class error inherits error ocur feature_list . ccur semi

    ccur            shift and go to state 69


state 57

    (9) def_class -> class error inherits type ocur feature_list . ccur semi

    ccur            shift and go to state 70


state 58

    (20) def_attr -> error colon type larrow . expr
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 71
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 59

    (32) param_list -> error param_list .

    cpar            reduce using rule 32 (param_list -> error param_list .)


state 60

    (24) def_func -> error opar formals cpar . colon type ocur expr ccur

    colon           shift and go to state 95


state 61

    (31) param_list -> param comma . param_list
    (30) param_list -> . param
    (31) param_list -> . param comma param_list
    (32) param_list -> . error param_list
    (34) param -> . id colon type

    error           shift and go to state 42
    id              shift and go to state 48

    param                          shift and go to state 46
    param_list                     shift and go to state 96

state 62

    (34) param -> id colon . type

    type            shift and go to state 97


state 63

    (17) def_attr -> id colon type larrow . expr
    (22) def_attr -> id colon type larrow . error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 99
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 98
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 64

    (21) def_attr -> id colon error larrow . expr
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 100
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 65

    (23) def_func -> id opar formals cpar . colon type ocur expr ccur
    (26) def_func -> id opar formals cpar . colon error ocur expr ccur
    (27) def_func -> id opar formals cpar . colon type ocur error ccur

    colon           shift and go to state 101


state 66

    (25) def_func -> id opar error cpar . colon type ocur expr ccur

    colon           shift and go to state 102


state 67

    (7) def_class -> class type inherits type ocur feature_list ccur . semi

    semi            shift and go to state 103


state 68

    (11) def_class -> class type inherits error ocur feature_list ccur . semi

    semi            shift and go to state 104


state 69

    (10) def_class -> class error inherits error ocur feature_list ccur . semi

    semi            shift and go to state 105


state 70

    (9) def_class -> class error inherits type ocur feature_list ccur . semi

    semi            shift and go to state 106


state 71

    (20) def_attr -> error colon type larrow expr .

    semi            reduce using rule 20 (def_attr -> error colon type larrow expr .)


state 72

    (35) expr -> let . let_list in expr
    (36) expr -> let . error in expr
    (37) expr -> let . let_list in error
    (50) let_list -> . let_assign
    (51) let_list -> . let_assign comma let_list
    (52) let_list -> . error let_list
    (53) let_assign -> . param larrow expr
    (54) let_assign -> . param
    (34) param -> . id colon type

    error           shift and go to state 108
    id              shift and go to state 48

    let_list                       shift and go to state 107
    let_assign                     shift and go to state 109
    param                          shift and go to state 110

state 73

    (38) expr -> case . expr of cases_list esac
    (39) expr -> case . error of cases_list esac
    (40) expr -> case . expr of error esac
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 112
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 111
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 74

    (41) expr -> if . expr then expr else expr fi
    (42) expr -> if . error then expr else expr fi
    (43) expr -> if . expr then error else expr fi
    (44) expr -> if . expr then expr else error fi
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 114
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 113
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 75

    (45) expr -> while . expr loop expr pool
    (46) expr -> while . error loop expr pool
    (47) expr -> while . expr loop error pool
    (48) expr -> while . expr loop expr error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 116
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 115
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 76

    (49) expr -> arith .

    semi            reduce using rule 49 (expr -> arith .)
    of              reduce using rule 49 (expr -> arith .)
    then            reduce using rule 49 (expr -> arith .)
    loop            reduce using rule 49 (expr -> arith .)
    cpar            reduce using rule 49 (expr -> arith .)
    comma           reduce using rule 49 (expr -> arith .)
    in              reduce using rule 49 (expr -> arith .)
    else            reduce using rule 49 (expr -> arith .)
    pool            reduce using rule 49 (expr -> arith .)
    error           reduce using rule 49 (expr -> arith .)
    ccur            reduce using rule 49 (expr -> arith .)
    fi              reduce using rule 49 (expr -> arith .)


state 77

    (59) arith -> id . larrow expr
    (81) atom -> id .
    (92) func_call -> id . opar args cpar

    larrow          shift and go to state 117
    arroba          reduce using rule 81 (atom -> id .)
    dot             reduce using rule 81 (atom -> id .)
    star            reduce using rule 81 (atom -> id .)
    div             reduce using rule 81 (atom -> id .)
    plus            reduce using rule 81 (atom -> id .)
    minus           reduce using rule 81 (atom -> id .)
    less            reduce using rule 81 (atom -> id .)
    lesseq          reduce using rule 81 (atom -> id .)
    equal           reduce using rule 81 (atom -> id .)
    semi            reduce using rule 81 (atom -> id .)
    of              reduce using rule 81 (atom -> id .)
    then            reduce using rule 81 (atom -> id .)
    loop            reduce using rule 81 (atom -> id .)
    cpar            reduce using rule 81 (atom -> id .)
    comma           reduce using rule 81 (atom -> id .)
    in              reduce using rule 81 (atom -> id .)
    else            reduce using rule 81 (atom -> id .)
    pool            reduce using rule 81 (atom -> id .)
    error           reduce using rule 81 (atom -> id .)
    ccur            reduce using rule 81 (atom -> id .)
    fi              reduce using rule 81 (atom -> id .)
    opar            shift and go to state 118


state 78

    (60) arith -> not . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    comp                           shift and go to state 119
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 79

    (61) arith -> comp .
    (62) comp -> comp . less op
    (63) comp -> comp . lesseq op
    (64) comp -> comp . equal op

    semi            reduce using rule 61 (arith -> comp .)
    of              reduce using rule 61 (arith -> comp .)
    then            reduce using rule 61 (arith -> comp .)
    loop            reduce using rule 61 (arith -> comp .)
    cpar            reduce using rule 61 (arith -> comp .)
    comma           reduce using rule 61 (arith -> comp .)
    in              reduce using rule 61 (arith -> comp .)
    else            reduce using rule 61 (arith -> comp .)
    pool            reduce using rule 61 (arith -> comp .)
    error           reduce using rule 61 (arith -> comp .)
    ccur            reduce using rule 61 (arith -> comp .)
    fi              reduce using rule 61 (arith -> comp .)
    less            shift and go to state 121
    lesseq          shift and go to state 122
    equal           shift and go to state 123


state 80

    (65) comp -> op .
    (66) op -> op . plus term
    (67) op -> op . minus term

    less            reduce using rule 65 (comp -> op .)
    lesseq          reduce using rule 65 (comp -> op .)
    equal           reduce using rule 65 (comp -> op .)
    semi            reduce using rule 65 (comp -> op .)
    of              reduce using rule 65 (comp -> op .)
    then            reduce using rule 65 (comp -> op .)
    loop            reduce using rule 65 (comp -> op .)
    cpar            reduce using rule 65 (comp -> op .)
    comma           reduce using rule 65 (comp -> op .)
    in              reduce using rule 65 (comp -> op .)
    else            reduce using rule 65 (comp -> op .)
    pool            reduce using rule 65 (comp -> op .)
    error           reduce using rule 65 (comp -> op .)
    ccur            reduce using rule 65 (comp -> op .)
    fi              reduce using rule 65 (comp -> op .)
    plus            shift and go to state 124
    minus           shift and go to state 125


state 81

    (68) op -> term .
    (69) term -> term . star base_call
    (70) term -> term . div base_call

    plus            reduce using rule 68 (op -> term .)
    minus           reduce using rule 68 (op -> term .)
    less            reduce using rule 68 (op -> term .)
    lesseq          reduce using rule 68 (op -> term .)
    equal           reduce using rule 68 (op -> term .)
    semi            reduce using rule 68 (op -> term .)
    of              reduce using rule 68 (op -> term .)
    then            reduce using rule 68 (op -> term .)
    loop            reduce using rule 68 (op -> term .)
    cpar            reduce using rule 68 (op -> term .)
    comma           reduce using rule 68 (op -> term .)
    in              reduce using rule 68 (op -> term .)
    else            reduce using rule 68 (op -> term .)
    pool            reduce using rule 68 (op -> term .)
    error           reduce using rule 68 (op -> term .)
    ccur            reduce using rule 68 (op -> term .)
    fi              reduce using rule 68 (op -> term .)
    star            shift and go to state 126
    div             shift and go to state 127


state 82

    (73) term -> base_call .

    star            reduce using rule 73 (term -> base_call .)
    div             reduce using rule 73 (term -> base_call .)
    plus            reduce using rule 73 (term -> base_call .)
    minus           reduce using rule 73 (term -> base_call .)
    less            reduce using rule 73 (term -> base_call .)
    lesseq          reduce using rule 73 (term -> base_call .)
    equal           reduce using rule 73 (term -> base_call .)
    semi            reduce using rule 73 (term -> base_call .)
    of              reduce using rule 73 (term -> base_call .)
    then            reduce using rule 73 (term -> base_call .)
    loop            reduce using rule 73 (term -> base_call .)
    cpar            reduce using rule 73 (term -> base_call .)
    comma           reduce using rule 73 (term -> base_call .)
    in              reduce using rule 73 (term -> base_call .)
    else            reduce using rule 73 (term -> base_call .)
    pool            reduce using rule 73 (term -> base_call .)
    error           reduce using rule 73 (term -> base_call .)
    ccur            reduce using rule 73 (term -> base_call .)
    fi              reduce using rule 73 (term -> base_call .)


state 83

    (71) term -> isvoid . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    base_call                      shift and go to state 128
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 84

    (72) term -> nox . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    base_call                      shift and go to state 129
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 85

    (74) base_call -> factor . arroba type dot func_call
    (75) base_call -> factor .
    (78) factor -> factor . dot func_call

    arroba          shift and go to state 130
    star            reduce using rule 75 (base_call -> factor .)
    div             reduce using rule 75 (base_call -> factor .)
    plus            reduce using rule 75 (base_call -> factor .)
    minus           reduce using rule 75 (base_call -> factor .)
    less            reduce using rule 75 (base_call -> factor .)
    lesseq          reduce using rule 75 (base_call -> factor .)
    equal           reduce using rule 75 (base_call -> factor .)
    semi            reduce using rule 75 (base_call -> factor .)
    of              reduce using rule 75 (base_call -> factor .)
    then            reduce using rule 75 (base_call -> factor .)
    loop            reduce using rule 75 (base_call -> factor .)
    cpar            reduce using rule 75 (base_call -> factor .)
    comma           reduce using rule 75 (base_call -> factor .)
    in              reduce using rule 75 (base_call -> factor .)
    else            reduce using rule 75 (base_call -> factor .)
    pool            reduce using rule 75 (base_call -> factor .)
    error           reduce using rule 75 (base_call -> factor .)
    ccur            reduce using rule 75 (base_call -> factor .)
    fi              reduce using rule 75 (base_call -> factor .)
    dot             shift and go to state 131


state 86

    (79) factor -> func_call .

    arroba          reduce using rule 79 (factor -> func_call .)
    dot             reduce using rule 79 (factor -> func_call .)
    star            reduce using rule 79 (factor -> func_call .)
    div             reduce using rule 79 (factor -> func_call .)
    plus            reduce using rule 79 (factor -> func_call .)
    minus           reduce using rule 79 (factor -> func_call .)
    less            reduce using rule 79 (factor -> func_call .)
    lesseq          reduce using rule 79 (factor -> func_call .)
    equal           reduce using rule 79 (factor -> func_call .)
    semi            reduce using rule 79 (factor -> func_call .)
    of              reduce using rule 79 (factor -> func_call .)
    then            reduce using rule 79 (factor -> func_call .)
    loop            reduce using rule 79 (factor -> func_call .)
    cpar            reduce using rule 79 (factor -> func_call .)
    comma           reduce using rule 79 (factor -> func_call .)
    in              reduce using rule 79 (factor -> func_call .)
    else            reduce using rule 79 (factor -> func_call .)
    pool            reduce using rule 79 (factor -> func_call .)
    error           reduce using rule 79 (factor -> func_call .)
    ccur            reduce using rule 79 (factor -> func_call .)
    fi              reduce using rule 79 (factor -> func_call .)


state 87

    (76) factor -> atom .

    arroba          reduce using rule 76 (factor -> atom .)
    dot             reduce using rule 76 (factor -> atom .)
    star            reduce using rule 76 (factor -> atom .)
    div             reduce using rule 76 (factor -> atom .)
    plus            reduce using rule 76 (factor -> atom .)
    minus           reduce using rule 76 (factor -> atom .)
    less            reduce using rule 76 (factor -> atom .)
    lesseq          reduce using rule 76 (factor -> atom .)
    equal           reduce using rule 76 (factor -> atom .)
    semi            reduce using rule 76 (factor -> atom .)
    of              reduce using rule 76 (factor -> atom .)
    then            reduce using rule 76 (factor -> atom .)
    loop            reduce using rule 76 (factor -> atom .)
    cpar            reduce using rule 76 (factor -> atom .)
    comma           reduce using rule 76 (factor -> atom .)
    in              reduce using rule 76 (factor -> atom .)
    else            reduce using rule 76 (factor -> atom .)
    pool            reduce using rule 76 (factor -> atom .)
    error           reduce using rule 76 (factor -> atom .)
    ccur            reduce using rule 76 (factor -> atom .)
    fi              reduce using rule 76 (factor -> atom .)


state 88

    (77) factor -> opar . expr cpar
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 132
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 89

    (80) atom -> num .

    arroba          reduce using rule 80 (atom -> num .)
    dot             reduce using rule 80 (atom -> num .)
    star            reduce using rule 80 (atom -> num .)
    div             reduce using rule 80 (atom -> num .)
    plus            reduce using rule 80 (atom -> num .)
    minus           reduce using rule 80 (atom -> num .)
    less            reduce using rule 80 (atom -> num .)
    lesseq          reduce using rule 80 (atom -> num .)
    equal           reduce using rule 80 (atom -> num .)
    semi            reduce using rule 80 (atom -> num .)
    of              reduce using rule 80 (atom -> num .)
    then            reduce using rule 80 (atom -> num .)
    loop            reduce using rule 80 (atom -> num .)
    cpar            reduce using rule 80 (atom -> num .)
    comma           reduce using rule 80 (atom -> num .)
    in              reduce using rule 80 (atom -> num .)
    else            reduce using rule 80 (atom -> num .)
    pool            reduce using rule 80 (atom -> num .)
    error           reduce using rule 80 (atom -> num .)
    ccur            reduce using rule 80 (atom -> num .)
    fi              reduce using rule 80 (atom -> num .)


state 90

    (82) atom -> new . type
    (83) atom -> new . error

    type            shift and go to state 133
    error           shift and go to state 134


state 91

    (84) atom -> ocur . block ccur
    (88) block -> . expr semi
    (89) block -> . expr semi block
    (90) block -> . error block
    (91) block -> . error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 137
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    block                          shift and go to state 135
    expr                           shift and go to state 136
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 92

    (85) atom -> true .

    arroba          reduce using rule 85 (atom -> true .)
    dot             reduce using rule 85 (atom -> true .)
    star            reduce using rule 85 (atom -> true .)
    div             reduce using rule 85 (atom -> true .)
    plus            reduce using rule 85 (atom -> true .)
    minus           reduce using rule 85 (atom -> true .)
    less            reduce using rule 85 (atom -> true .)
    lesseq          reduce using rule 85 (atom -> true .)
    equal           reduce using rule 85 (atom -> true .)
    semi            reduce using rule 85 (atom -> true .)
    of              reduce using rule 85 (atom -> true .)
    then            reduce using rule 85 (atom -> true .)
    loop            reduce using rule 85 (atom -> true .)
    cpar            reduce using rule 85 (atom -> true .)
    comma           reduce using rule 85 (atom -> true .)
    in              reduce using rule 85 (atom -> true .)
    else            reduce using rule 85 (atom -> true .)
    pool            reduce using rule 85 (atom -> true .)
    error           reduce using rule 85 (atom -> true .)
    ccur            reduce using rule 85 (atom -> true .)
    fi              reduce using rule 85 (atom -> true .)


state 93

    (86) atom -> false .

    arroba          reduce using rule 86 (atom -> false .)
    dot             reduce using rule 86 (atom -> false .)
    star            reduce using rule 86 (atom -> false .)
    div             reduce using rule 86 (atom -> false .)
    plus            reduce using rule 86 (atom -> false .)
    minus           reduce using rule 86 (atom -> false .)
    less            reduce using rule 86 (atom -> false .)
    lesseq          reduce using rule 86 (atom -> false .)
    equal           reduce using rule 86 (atom -> false .)
    semi            reduce using rule 86 (atom -> false .)
    of              reduce using rule 86 (atom -> false .)
    then            reduce using rule 86 (atom -> false .)
    loop            reduce using rule 86 (atom -> false .)
    cpar            reduce using rule 86 (atom -> false .)
    comma           reduce using rule 86 (atom -> false .)
    in              reduce using rule 86 (atom -> false .)
    else            reduce using rule 86 (atom -> false .)
    pool            reduce using rule 86 (atom -> false .)
    error           reduce using rule 86 (atom -> false .)
    ccur            reduce using rule 86 (atom -> false .)
    fi              reduce using rule 86 (atom -> false .)


state 94

    (87) atom -> string .

    arroba          reduce using rule 87 (atom -> string .)
    dot             reduce using rule 87 (atom -> string .)
    star            reduce using rule 87 (atom -> string .)
    div             reduce using rule 87 (atom -> string .)
    plus            reduce using rule 87 (atom -> string .)
    minus           reduce using rule 87 (atom -> string .)
    less            reduce using rule 87 (atom -> string .)
    lesseq          reduce using rule 87 (atom -> string .)
    equal           reduce using rule 87 (atom -> string .)
    semi            reduce using rule 87 (atom -> string .)
    of              reduce using rule 87 (atom -> string .)
    then            reduce using rule 87 (atom -> string .)
    loop            reduce using rule 87 (atom -> string .)
    cpar            reduce using rule 87 (atom -> string .)
    comma           reduce using rule 87 (atom -> string .)
    in              reduce using rule 87 (atom -> string .)
    else            reduce using rule 87 (atom -> string .)
    pool            reduce using rule 87 (atom -> string .)
    error           reduce using rule 87 (atom -> string .)
    ccur            reduce using rule 87 (atom -> string .)
    fi              reduce using rule 87 (atom -> string .)


state 95

    (24) def_func -> error opar formals cpar colon . type ocur expr ccur

    type            shift and go to state 138


state 96

    (31) param_list -> param comma param_list .

    cpar            reduce using rule 31 (param_list -> param comma param_list .)


state 97

    (34) param -> id colon type .

    comma           reduce using rule 34 (param -> id colon type .)
    cpar            reduce using rule 34 (param -> id colon type .)
    larrow          reduce using rule 34 (param -> id colon type .)
    in              reduce using rule 34 (param -> id colon type .)


state 98

    (17) def_attr -> id colon type larrow expr .

    semi            reduce using rule 17 (def_attr -> id colon type larrow expr .)


state 99

    (22) def_attr -> id colon type larrow error .

    semi            reduce using rule 22 (def_attr -> id colon type larrow error .)


state 100

    (21) def_attr -> id colon error larrow expr .

    semi            reduce using rule 21 (def_attr -> id colon error larrow expr .)


state 101

    (23) def_func -> id opar formals cpar colon . type ocur expr ccur
    (26) def_func -> id opar formals cpar colon . error ocur expr ccur
    (27) def_func -> id opar formals cpar colon . type ocur error ccur

    type            shift and go to state 139
    error           shift and go to state 140


state 102

    (25) def_func -> id opar error cpar colon . type ocur expr ccur

    type            shift and go to state 141


state 103

    (7) def_class -> class type inherits type ocur feature_list ccur semi .

    error           reduce using rule 7 (def_class -> class type inherits type ocur feature_list ccur semi .)
    class           reduce using rule 7 (def_class -> class type inherits type ocur feature_list ccur semi .)
    $end            reduce using rule 7 (def_class -> class type inherits type ocur feature_list ccur semi .)


state 104

    (11) def_class -> class type inherits error ocur feature_list ccur semi .

    error           reduce using rule 11 (def_class -> class type inherits error ocur feature_list ccur semi .)
    class           reduce using rule 11 (def_class -> class type inherits error ocur feature_list ccur semi .)
    $end            reduce using rule 11 (def_class -> class type inherits error ocur feature_list ccur semi .)


state 105

    (10) def_class -> class error inherits error ocur feature_list ccur semi .

    error           reduce using rule 10 (def_class -> class error inherits error ocur feature_list ccur semi .)
    class           reduce using rule 10 (def_class -> class error inherits error ocur feature_list ccur semi .)
    $end            reduce using rule 10 (def_class -> class error inherits error ocur feature_list ccur semi .)


state 106

    (9) def_class -> class error inherits type ocur feature_list ccur semi .

    error           reduce using rule 9 (def_class -> class error inherits type ocur feature_list ccur semi .)
    class           reduce using rule 9 (def_class -> class error inherits type ocur feature_list ccur semi .)
    $end            reduce using rule 9 (def_class -> class error inherits type ocur feature_list ccur semi .)


state 107

    (35) expr -> let let_list . in expr
    (37) expr -> let let_list . in error

    in              shift and go to state 142


state 108

    (36) expr -> let error . in expr
    (52) let_list -> error . let_list
    (50) let_list -> . let_assign
    (51) let_list -> . let_assign comma let_list
    (52) let_list -> . error let_list
    (53) let_assign -> . param larrow expr
    (54) let_assign -> . param
    (34) param -> . id colon type

    in              shift and go to state 144
    error           shift and go to state 143
    id              shift and go to state 48

    let_list                       shift and go to state 145
    let_assign                     shift and go to state 109
    param                          shift and go to state 110

state 109

    (50) let_list -> let_assign .
    (51) let_list -> let_assign . comma let_list

    in              reduce using rule 50 (let_list -> let_assign .)
    comma           shift and go to state 146


state 110

    (53) let_assign -> param . larrow expr
    (54) let_assign -> param .

    larrow          shift and go to state 147
    comma           reduce using rule 54 (let_assign -> param .)
    in              reduce using rule 54 (let_assign -> param .)


state 111

    (38) expr -> case expr . of cases_list esac
    (40) expr -> case expr . of error esac

    of              shift and go to state 148


state 112

    (39) expr -> case error . of cases_list esac

    of              shift and go to state 149


state 113

    (41) expr -> if expr . then expr else expr fi
    (43) expr -> if expr . then error else expr fi
    (44) expr -> if expr . then expr else error fi

    then            shift and go to state 150


state 114

    (42) expr -> if error . then expr else expr fi

    then            shift and go to state 151


state 115

    (45) expr -> while expr . loop expr pool
    (47) expr -> while expr . loop error pool
    (48) expr -> while expr . loop expr error

    loop            shift and go to state 152


state 116

    (46) expr -> while error . loop expr pool

    loop            shift and go to state 153


state 117

    (59) arith -> id larrow . expr
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 154
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 118

    (92) func_call -> id opar . args cpar
    (93) args -> . arg_list
    (94) args -> . arg_list_empty
    (95) arg_list -> . expr
    (96) arg_list -> . expr comma arg_list
    (97) arg_list -> . error arg_list
    (98) arg_list_empty -> . epsilon
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (2) epsilon -> .
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 159
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    cpar            reduce using rule 2 (epsilon -> .)
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    args                           shift and go to state 155
    arg_list                       shift and go to state 156
    arg_list_empty                 shift and go to state 157
    expr                           shift and go to state 158
    epsilon                        shift and go to state 160
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 119

    (60) arith -> not comp .
    (62) comp -> comp . less op
    (63) comp -> comp . lesseq op
    (64) comp -> comp . equal op

    semi            reduce using rule 60 (arith -> not comp .)
    of              reduce using rule 60 (arith -> not comp .)
    then            reduce using rule 60 (arith -> not comp .)
    loop            reduce using rule 60 (arith -> not comp .)
    cpar            reduce using rule 60 (arith -> not comp .)
    comma           reduce using rule 60 (arith -> not comp .)
    in              reduce using rule 60 (arith -> not comp .)
    else            reduce using rule 60 (arith -> not comp .)
    pool            reduce using rule 60 (arith -> not comp .)
    error           reduce using rule 60 (arith -> not comp .)
    ccur            reduce using rule 60 (arith -> not comp .)
    fi              reduce using rule 60 (arith -> not comp .)
    less            shift and go to state 121
    lesseq          shift and go to state 122
    equal           shift and go to state 123


state 120

    (81) atom -> id .
    (92) func_call -> id . opar args cpar

    arroba          reduce using rule 81 (atom -> id .)
    dot             reduce using rule 81 (atom -> id .)
    star            reduce using rule 81 (atom -> id .)
    div             reduce using rule 81 (atom -> id .)
    plus            reduce using rule 81 (atom -> id .)
    minus           reduce using rule 81 (atom -> id .)
    less            reduce using rule 81 (atom -> id .)
    lesseq          reduce using rule 81 (atom -> id .)
    equal           reduce using rule 81 (atom -> id .)
    semi            reduce using rule 81 (atom -> id .)
    of              reduce using rule 81 (atom -> id .)
    then            reduce using rule 81 (atom -> id .)
    loop            reduce using rule 81 (atom -> id .)
    cpar            reduce using rule 81 (atom -> id .)
    comma           reduce using rule 81 (atom -> id .)
    in              reduce using rule 81 (atom -> id .)
    else            reduce using rule 81 (atom -> id .)
    pool            reduce using rule 81 (atom -> id .)
    error           reduce using rule 81 (atom -> id .)
    ccur            reduce using rule 81 (atom -> id .)
    fi              reduce using rule 81 (atom -> id .)
    opar            shift and go to state 118


state 121

    (62) comp -> comp less . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    op                             shift and go to state 161
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 122

    (63) comp -> comp lesseq . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    op                             shift and go to state 162
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 123

    (64) comp -> comp equal . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    op                             shift and go to state 163
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 124

    (66) op -> op plus . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    term                           shift and go to state 164
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 125

    (67) op -> op minus . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    term                           shift and go to state 165
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 126

    (69) term -> term star . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    base_call                      shift and go to state 166
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 127

    (70) term -> term div . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    opar            shift and go to state 88
    num             shift and go to state 89
    id              shift and go to state 120
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    base_call                      shift and go to state 167
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 128

    (71) term -> isvoid base_call .

    star            reduce using rule 71 (term -> isvoid base_call .)
    div             reduce using rule 71 (term -> isvoid base_call .)
    plus            reduce using rule 71 (term -> isvoid base_call .)
    minus           reduce using rule 71 (term -> isvoid base_call .)
    less            reduce using rule 71 (term -> isvoid base_call .)
    lesseq          reduce using rule 71 (term -> isvoid base_call .)
    equal           reduce using rule 71 (term -> isvoid base_call .)
    semi            reduce using rule 71 (term -> isvoid base_call .)
    of              reduce using rule 71 (term -> isvoid base_call .)
    then            reduce using rule 71 (term -> isvoid base_call .)
    loop            reduce using rule 71 (term -> isvoid base_call .)
    cpar            reduce using rule 71 (term -> isvoid base_call .)
    comma           reduce using rule 71 (term -> isvoid base_call .)
    in              reduce using rule 71 (term -> isvoid base_call .)
    else            reduce using rule 71 (term -> isvoid base_call .)
    pool            reduce using rule 71 (term -> isvoid base_call .)
    error           reduce using rule 71 (term -> isvoid base_call .)
    ccur            reduce using rule 71 (term -> isvoid base_call .)
    fi              reduce using rule 71 (term -> isvoid base_call .)


state 129

    (72) term -> nox base_call .

    star            reduce using rule 72 (term -> nox base_call .)
    div             reduce using rule 72 (term -> nox base_call .)
    plus            reduce using rule 72 (term -> nox base_call .)
    minus           reduce using rule 72 (term -> nox base_call .)
    less            reduce using rule 72 (term -> nox base_call .)
    lesseq          reduce using rule 72 (term -> nox base_call .)
    equal           reduce using rule 72 (term -> nox base_call .)
    semi            reduce using rule 72 (term -> nox base_call .)
    of              reduce using rule 72 (term -> nox base_call .)
    then            reduce using rule 72 (term -> nox base_call .)
    loop            reduce using rule 72 (term -> nox base_call .)
    cpar            reduce using rule 72 (term -> nox base_call .)
    comma           reduce using rule 72 (term -> nox base_call .)
    in              reduce using rule 72 (term -> nox base_call .)
    else            reduce using rule 72 (term -> nox base_call .)
    pool            reduce using rule 72 (term -> nox base_call .)
    error           reduce using rule 72 (term -> nox base_call .)
    ccur            reduce using rule 72 (term -> nox base_call .)
    fi              reduce using rule 72 (term -> nox base_call .)


state 130

    (74) base_call -> factor arroba . type dot func_call

    type            shift and go to state 168


state 131

    (78) factor -> factor dot . func_call
    (92) func_call -> . id opar args cpar

    id              shift and go to state 170

    func_call                      shift and go to state 169

state 132

    (77) factor -> opar expr . cpar

    cpar            shift and go to state 171


state 133

    (82) atom -> new type .

    arroba          reduce using rule 82 (atom -> new type .)
    dot             reduce using rule 82 (atom -> new type .)
    star            reduce using rule 82 (atom -> new type .)
    div             reduce using rule 82 (atom -> new type .)
    plus            reduce using rule 82 (atom -> new type .)
    minus           reduce using rule 82 (atom -> new type .)
    less            reduce using rule 82 (atom -> new type .)
    lesseq          reduce using rule 82 (atom -> new type .)
    equal           reduce using rule 82 (atom -> new type .)
    semi            reduce using rule 82 (atom -> new type .)
    of              reduce using rule 82 (atom -> new type .)
    then            reduce using rule 82 (atom -> new type .)
    loop            reduce using rule 82 (atom -> new type .)
    cpar            reduce using rule 82 (atom -> new type .)
    comma           reduce using rule 82 (atom -> new type .)
    in              reduce using rule 82 (atom -> new type .)
    else            reduce using rule 82 (atom -> new type .)
    pool            reduce using rule 82 (atom -> new type .)
    error           reduce using rule 82 (atom -> new type .)
    ccur            reduce using rule 82 (atom -> new type .)
    fi              reduce using rule 82 (atom -> new type .)


state 134

    (83) atom -> new error .

    arroba          reduce using rule 83 (atom -> new error .)
    dot             reduce using rule 83 (atom -> new error .)
    star            reduce using rule 83 (atom -> new error .)
    div             reduce using rule 83 (atom -> new error .)
    plus            reduce using rule 83 (atom -> new error .)
    minus           reduce using rule 83 (atom -> new error .)
    less            reduce using rule 83 (atom -> new error .)
    lesseq          reduce using rule 83 (atom -> new error .)
    equal           reduce using rule 83 (atom -> new error .)
    semi            reduce using rule 83 (atom -> new error .)
    of              reduce using rule 83 (atom -> new error .)
    then            reduce using rule 83 (atom -> new error .)
    loop            reduce using rule 83 (atom -> new error .)
    cpar            reduce using rule 83 (atom -> new error .)
    comma           reduce using rule 83 (atom -> new error .)
    in              reduce using rule 83 (atom -> new error .)
    else            reduce using rule 83 (atom -> new error .)
    pool            reduce using rule 83 (atom -> new error .)
    error           reduce using rule 83 (atom -> new error .)
    ccur            reduce using rule 83 (atom -> new error .)
    fi              reduce using rule 83 (atom -> new error .)


state 135

    (84) atom -> ocur block . ccur

    ccur            shift and go to state 172


state 136

    (88) block -> expr . semi
    (89) block -> expr . semi block

    semi            shift and go to state 173


state 137

    (90) block -> error . block
    (91) block -> error .
    (88) block -> . expr semi
    (89) block -> . expr semi block
    (90) block -> . error block
    (91) block -> . error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    ccur            reduce using rule 91 (block -> error .)
    error           shift and go to state 137
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    block                          shift and go to state 174
    expr                           shift and go to state 136
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 138

    (24) def_func -> error opar formals cpar colon type . ocur expr ccur

    ocur            shift and go to state 175


state 139

    (23) def_func -> id opar formals cpar colon type . ocur expr ccur
    (27) def_func -> id opar formals cpar colon type . ocur error ccur

    ocur            shift and go to state 176


state 140

    (26) def_func -> id opar formals cpar colon error . ocur expr ccur

    ocur            shift and go to state 177


state 141

    (25) def_func -> id opar error cpar colon type . ocur expr ccur

    ocur            shift and go to state 178


state 142

    (35) expr -> let let_list in . expr
    (37) expr -> let let_list in . error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 180
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 179
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 143

    (52) let_list -> error . let_list
    (50) let_list -> . let_assign
    (51) let_list -> . let_assign comma let_list
    (52) let_list -> . error let_list
    (53) let_assign -> . param larrow expr
    (54) let_assign -> . param
    (34) param -> . id colon type

    error           shift and go to state 143
    id              shift and go to state 48

    let_list                       shift and go to state 145
    let_assign                     shift and go to state 109
    param                          shift and go to state 110

state 144

    (36) expr -> let error in . expr
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 181
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 145

    (52) let_list -> error let_list .

    in              reduce using rule 52 (let_list -> error let_list .)


state 146

    (51) let_list -> let_assign comma . let_list
    (50) let_list -> . let_assign
    (51) let_list -> . let_assign comma let_list
    (52) let_list -> . error let_list
    (53) let_assign -> . param larrow expr
    (54) let_assign -> . param
    (34) param -> . id colon type

    error           shift and go to state 143
    id              shift and go to state 48

    let_assign                     shift and go to state 109
    let_list                       shift and go to state 182
    param                          shift and go to state 110

state 147

    (53) let_assign -> param larrow . expr
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 183
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 148

    (38) expr -> case expr of . cases_list esac
    (40) expr -> case expr of . error esac
    (55) cases_list -> . casep semi
    (56) cases_list -> . casep semi cases_list
    (57) cases_list -> . error cases_list
    (58) casep -> . id colon type rarrow expr

    error           shift and go to state 185
    id              shift and go to state 187

    cases_list                     shift and go to state 184
    casep                          shift and go to state 186

state 149

    (39) expr -> case error of . cases_list esac
    (55) cases_list -> . casep semi
    (56) cases_list -> . casep semi cases_list
    (57) cases_list -> . error cases_list
    (58) casep -> . id colon type rarrow expr

    error           shift and go to state 188
    id              shift and go to state 187

    cases_list                     shift and go to state 189
    casep                          shift and go to state 186

state 150

    (41) expr -> if expr then . expr else expr fi
    (43) expr -> if expr then . error else expr fi
    (44) expr -> if expr then . expr else error fi
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 191
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 190
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 151

    (42) expr -> if error then . expr else expr fi
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 192
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 152

    (45) expr -> while expr loop . expr pool
    (47) expr -> while expr loop . error pool
    (48) expr -> while expr loop . expr error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 194
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 193
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 153

    (46) expr -> while error loop . expr pool
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 195
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 154

    (59) arith -> id larrow expr .

    semi            reduce using rule 59 (arith -> id larrow expr .)
    of              reduce using rule 59 (arith -> id larrow expr .)
    then            reduce using rule 59 (arith -> id larrow expr .)
    loop            reduce using rule 59 (arith -> id larrow expr .)
    cpar            reduce using rule 59 (arith -> id larrow expr .)
    comma           reduce using rule 59 (arith -> id larrow expr .)
    in              reduce using rule 59 (arith -> id larrow expr .)
    else            reduce using rule 59 (arith -> id larrow expr .)
    pool            reduce using rule 59 (arith -> id larrow expr .)
    error           reduce using rule 59 (arith -> id larrow expr .)
    ccur            reduce using rule 59 (arith -> id larrow expr .)
    fi              reduce using rule 59 (arith -> id larrow expr .)


state 155

    (92) func_call -> id opar args . cpar

    cpar            shift and go to state 196


state 156

    (93) args -> arg_list .

    cpar            reduce using rule 93 (args -> arg_list .)


state 157

    (94) args -> arg_list_empty .

    cpar            reduce using rule 94 (args -> arg_list_empty .)


state 158

    (95) arg_list -> expr .
    (96) arg_list -> expr . comma arg_list

    cpar            reduce using rule 95 (arg_list -> expr .)
    comma           shift and go to state 197


state 159

    (97) arg_list -> error . arg_list
    (95) arg_list -> . expr
    (96) arg_list -> . expr comma arg_list
    (97) arg_list -> . error arg_list
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 159
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    arg_list                       shift and go to state 198
    expr                           shift and go to state 158
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 160

    (98) arg_list_empty -> epsilon .

    cpar            reduce using rule 98 (arg_list_empty -> epsilon .)


state 161

    (62) comp -> comp less op .
    (66) op -> op . plus term
    (67) op -> op . minus term

    less            reduce using rule 62 (comp -> comp less op .)
    lesseq          reduce using rule 62 (comp -> comp less op .)
    equal           reduce using rule 62 (comp -> comp less op .)
    semi            reduce using rule 62 (comp -> comp less op .)
    of              reduce using rule 62 (comp -> comp less op .)
    then            reduce using rule 62 (comp -> comp less op .)
    loop            reduce using rule 62 (comp -> comp less op .)
    cpar            reduce using rule 62 (comp -> comp less op .)
    comma           reduce using rule 62 (comp -> comp less op .)
    in              reduce using rule 62 (comp -> comp less op .)
    else            reduce using rule 62 (comp -> comp less op .)
    pool            reduce using rule 62 (comp -> comp less op .)
    error           reduce using rule 62 (comp -> comp less op .)
    ccur            reduce using rule 62 (comp -> comp less op .)
    fi              reduce using rule 62 (comp -> comp less op .)
    plus            shift and go to state 124
    minus           shift and go to state 125


state 162

    (63) comp -> comp lesseq op .
    (66) op -> op . plus term
    (67) op -> op . minus term

    less            reduce using rule 63 (comp -> comp lesseq op .)
    lesseq          reduce using rule 63 (comp -> comp lesseq op .)
    equal           reduce using rule 63 (comp -> comp lesseq op .)
    semi            reduce using rule 63 (comp -> comp lesseq op .)
    of              reduce using rule 63 (comp -> comp lesseq op .)
    then            reduce using rule 63 (comp -> comp lesseq op .)
    loop            reduce using rule 63 (comp -> comp lesseq op .)
    cpar            reduce using rule 63 (comp -> comp lesseq op .)
    comma           reduce using rule 63 (comp -> comp lesseq op .)
    in              reduce using rule 63 (comp -> comp lesseq op .)
    else            reduce using rule 63 (comp -> comp lesseq op .)
    pool            reduce using rule 63 (comp -> comp lesseq op .)
    error           reduce using rule 63 (comp -> comp lesseq op .)
    ccur            reduce using rule 63 (comp -> comp lesseq op .)
    fi              reduce using rule 63 (comp -> comp lesseq op .)
    plus            shift and go to state 124
    minus           shift and go to state 125


state 163

    (64) comp -> comp equal op .
    (66) op -> op . plus term
    (67) op -> op . minus term

    less            reduce using rule 64 (comp -> comp equal op .)
    lesseq          reduce using rule 64 (comp -> comp equal op .)
    equal           reduce using rule 64 (comp -> comp equal op .)
    semi            reduce using rule 64 (comp -> comp equal op .)
    of              reduce using rule 64 (comp -> comp equal op .)
    then            reduce using rule 64 (comp -> comp equal op .)
    loop            reduce using rule 64 (comp -> comp equal op .)
    cpar            reduce using rule 64 (comp -> comp equal op .)
    comma           reduce using rule 64 (comp -> comp equal op .)
    in              reduce using rule 64 (comp -> comp equal op .)
    else            reduce using rule 64 (comp -> comp equal op .)
    pool            reduce using rule 64 (comp -> comp equal op .)
    error           reduce using rule 64 (comp -> comp equal op .)
    ccur            reduce using rule 64 (comp -> comp equal op .)
    fi              reduce using rule 64 (comp -> comp equal op .)
    plus            shift and go to state 124
    minus           shift and go to state 125


state 164

    (66) op -> op plus term .
    (69) term -> term . star base_call
    (70) term -> term . div base_call

    plus            reduce using rule 66 (op -> op plus term .)
    minus           reduce using rule 66 (op -> op plus term .)
    less            reduce using rule 66 (op -> op plus term .)
    lesseq          reduce using rule 66 (op -> op plus term .)
    equal           reduce using rule 66 (op -> op plus term .)
    semi            reduce using rule 66 (op -> op plus term .)
    of              reduce using rule 66 (op -> op plus term .)
    then            reduce using rule 66 (op -> op plus term .)
    loop            reduce using rule 66 (op -> op plus term .)
    cpar            reduce using rule 66 (op -> op plus term .)
    comma           reduce using rule 66 (op -> op plus term .)
    in              reduce using rule 66 (op -> op plus term .)
    else            reduce using rule 66 (op -> op plus term .)
    pool            reduce using rule 66 (op -> op plus term .)
    error           reduce using rule 66 (op -> op plus term .)
    ccur            reduce using rule 66 (op -> op plus term .)
    fi              reduce using rule 66 (op -> op plus term .)
    star            shift and go to state 126
    div             shift and go to state 127


state 165

    (67) op -> op minus term .
    (69) term -> term . star base_call
    (70) term -> term . div base_call

    plus            reduce using rule 67 (op -> op minus term .)
    minus           reduce using rule 67 (op -> op minus term .)
    less            reduce using rule 67 (op -> op minus term .)
    lesseq          reduce using rule 67 (op -> op minus term .)
    equal           reduce using rule 67 (op -> op minus term .)
    semi            reduce using rule 67 (op -> op minus term .)
    of              reduce using rule 67 (op -> op minus term .)
    then            reduce using rule 67 (op -> op minus term .)
    loop            reduce using rule 67 (op -> op minus term .)
    cpar            reduce using rule 67 (op -> op minus term .)
    comma           reduce using rule 67 (op -> op minus term .)
    in              reduce using rule 67 (op -> op minus term .)
    else            reduce using rule 67 (op -> op minus term .)
    pool            reduce using rule 67 (op -> op minus term .)
    error           reduce using rule 67 (op -> op minus term .)
    ccur            reduce using rule 67 (op -> op minus term .)
    fi              reduce using rule 67 (op -> op minus term .)
    star            shift and go to state 126
    div             shift and go to state 127


state 166

    (69) term -> term star base_call .

    star            reduce using rule 69 (term -> term star base_call .)
    div             reduce using rule 69 (term -> term star base_call .)
    plus            reduce using rule 69 (term -> term star base_call .)
    minus           reduce using rule 69 (term -> term star base_call .)
    less            reduce using rule 69 (term -> term star base_call .)
    lesseq          reduce using rule 69 (term -> term star base_call .)
    equal           reduce using rule 69 (term -> term star base_call .)
    semi            reduce using rule 69 (term -> term star base_call .)
    of              reduce using rule 69 (term -> term star base_call .)
    then            reduce using rule 69 (term -> term star base_call .)
    loop            reduce using rule 69 (term -> term star base_call .)
    cpar            reduce using rule 69 (term -> term star base_call .)
    comma           reduce using rule 69 (term -> term star base_call .)
    in              reduce using rule 69 (term -> term star base_call .)
    else            reduce using rule 69 (term -> term star base_call .)
    pool            reduce using rule 69 (term -> term star base_call .)
    error           reduce using rule 69 (term -> term star base_call .)
    ccur            reduce using rule 69 (term -> term star base_call .)
    fi              reduce using rule 69 (term -> term star base_call .)


state 167

    (70) term -> term div base_call .

    star            reduce using rule 70 (term -> term div base_call .)
    div             reduce using rule 70 (term -> term div base_call .)
    plus            reduce using rule 70 (term -> term div base_call .)
    minus           reduce using rule 70 (term -> term div base_call .)
    less            reduce using rule 70 (term -> term div base_call .)
    lesseq          reduce using rule 70 (term -> term div base_call .)
    equal           reduce using rule 70 (term -> term div base_call .)
    semi            reduce using rule 70 (term -> term div base_call .)
    of              reduce using rule 70 (term -> term div base_call .)
    then            reduce using rule 70 (term -> term div base_call .)
    loop            reduce using rule 70 (term -> term div base_call .)
    cpar            reduce using rule 70 (term -> term div base_call .)
    comma           reduce using rule 70 (term -> term div base_call .)
    in              reduce using rule 70 (term -> term div base_call .)
    else            reduce using rule 70 (term -> term div base_call .)
    pool            reduce using rule 70 (term -> term div base_call .)
    error           reduce using rule 70 (term -> term div base_call .)
    ccur            reduce using rule 70 (term -> term div base_call .)
    fi              reduce using rule 70 (term -> term div base_call .)


state 168

    (74) base_call -> factor arroba type . dot func_call

    dot             shift and go to state 199


state 169

    (78) factor -> factor dot func_call .

    arroba          reduce using rule 78 (factor -> factor dot func_call .)
    dot             reduce using rule 78 (factor -> factor dot func_call .)
    star            reduce using rule 78 (factor -> factor dot func_call .)
    div             reduce using rule 78 (factor -> factor dot func_call .)
    plus            reduce using rule 78 (factor -> factor dot func_call .)
    minus           reduce using rule 78 (factor -> factor dot func_call .)
    less            reduce using rule 78 (factor -> factor dot func_call .)
    lesseq          reduce using rule 78 (factor -> factor dot func_call .)
    equal           reduce using rule 78 (factor -> factor dot func_call .)
    semi            reduce using rule 78 (factor -> factor dot func_call .)
    of              reduce using rule 78 (factor -> factor dot func_call .)
    then            reduce using rule 78 (factor -> factor dot func_call .)
    loop            reduce using rule 78 (factor -> factor dot func_call .)
    cpar            reduce using rule 78 (factor -> factor dot func_call .)
    comma           reduce using rule 78 (factor -> factor dot func_call .)
    in              reduce using rule 78 (factor -> factor dot func_call .)
    else            reduce using rule 78 (factor -> factor dot func_call .)
    pool            reduce using rule 78 (factor -> factor dot func_call .)
    error           reduce using rule 78 (factor -> factor dot func_call .)
    ccur            reduce using rule 78 (factor -> factor dot func_call .)
    fi              reduce using rule 78 (factor -> factor dot func_call .)


state 170

    (92) func_call -> id . opar args cpar

    opar            shift and go to state 118


state 171

    (77) factor -> opar expr cpar .

    arroba          reduce using rule 77 (factor -> opar expr cpar .)
    dot             reduce using rule 77 (factor -> opar expr cpar .)
    star            reduce using rule 77 (factor -> opar expr cpar .)
    div             reduce using rule 77 (factor -> opar expr cpar .)
    plus            reduce using rule 77 (factor -> opar expr cpar .)
    minus           reduce using rule 77 (factor -> opar expr cpar .)
    less            reduce using rule 77 (factor -> opar expr cpar .)
    lesseq          reduce using rule 77 (factor -> opar expr cpar .)
    equal           reduce using rule 77 (factor -> opar expr cpar .)
    semi            reduce using rule 77 (factor -> opar expr cpar .)
    of              reduce using rule 77 (factor -> opar expr cpar .)
    then            reduce using rule 77 (factor -> opar expr cpar .)
    loop            reduce using rule 77 (factor -> opar expr cpar .)
    cpar            reduce using rule 77 (factor -> opar expr cpar .)
    comma           reduce using rule 77 (factor -> opar expr cpar .)
    in              reduce using rule 77 (factor -> opar expr cpar .)
    else            reduce using rule 77 (factor -> opar expr cpar .)
    pool            reduce using rule 77 (factor -> opar expr cpar .)
    error           reduce using rule 77 (factor -> opar expr cpar .)
    ccur            reduce using rule 77 (factor -> opar expr cpar .)
    fi              reduce using rule 77 (factor -> opar expr cpar .)


state 172

    (84) atom -> ocur block ccur .

    arroba          reduce using rule 84 (atom -> ocur block ccur .)
    dot             reduce using rule 84 (atom -> ocur block ccur .)
    star            reduce using rule 84 (atom -> ocur block ccur .)
    div             reduce using rule 84 (atom -> ocur block ccur .)
    plus            reduce using rule 84 (atom -> ocur block ccur .)
    minus           reduce using rule 84 (atom -> ocur block ccur .)
    less            reduce using rule 84 (atom -> ocur block ccur .)
    lesseq          reduce using rule 84 (atom -> ocur block ccur .)
    equal           reduce using rule 84 (atom -> ocur block ccur .)
    semi            reduce using rule 84 (atom -> ocur block ccur .)
    of              reduce using rule 84 (atom -> ocur block ccur .)
    then            reduce using rule 84 (atom -> ocur block ccur .)
    loop            reduce using rule 84 (atom -> ocur block ccur .)
    cpar            reduce using rule 84 (atom -> ocur block ccur .)
    comma           reduce using rule 84 (atom -> ocur block ccur .)
    in              reduce using rule 84 (atom -> ocur block ccur .)
    else            reduce using rule 84 (atom -> ocur block ccur .)
    pool            reduce using rule 84 (atom -> ocur block ccur .)
    error           reduce using rule 84 (atom -> ocur block ccur .)
    ccur            reduce using rule 84 (atom -> ocur block ccur .)
    fi              reduce using rule 84 (atom -> ocur block ccur .)


state 173

    (88) block -> expr semi .
    (89) block -> expr semi . block
    (88) block -> . expr semi
    (89) block -> . expr semi block
    (90) block -> . error block
    (91) block -> . error
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    ccur            reduce using rule 88 (block -> expr semi .)
    error           shift and go to state 137
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 136
    block                          shift and go to state 200
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 174

    (90) block -> error block .

    ccur            reduce using rule 90 (block -> error block .)


state 175

    (24) def_func -> error opar formals cpar colon type ocur . expr ccur
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 201
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 176

    (23) def_func -> id opar formals cpar colon type ocur . expr ccur
    (27) def_func -> id opar formals cpar colon type ocur . error ccur
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 203
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 202
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 177

    (26) def_func -> id opar formals cpar colon error ocur . expr ccur
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 204
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 178

    (25) def_func -> id opar error cpar colon type ocur . expr ccur
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 205
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 179

    (35) expr -> let let_list in expr .

    semi            reduce using rule 35 (expr -> let let_list in expr .)
    of              reduce using rule 35 (expr -> let let_list in expr .)
    then            reduce using rule 35 (expr -> let let_list in expr .)
    loop            reduce using rule 35 (expr -> let let_list in expr .)
    cpar            reduce using rule 35 (expr -> let let_list in expr .)
    comma           reduce using rule 35 (expr -> let let_list in expr .)
    in              reduce using rule 35 (expr -> let let_list in expr .)
    else            reduce using rule 35 (expr -> let let_list in expr .)
    pool            reduce using rule 35 (expr -> let let_list in expr .)
    error           reduce using rule 35 (expr -> let let_list in expr .)
    ccur            reduce using rule 35 (expr -> let let_list in expr .)
    fi              reduce using rule 35 (expr -> let let_list in expr .)


state 180

    (37) expr -> let let_list in error .

    semi            reduce using rule 37 (expr -> let let_list in error .)
    of              reduce using rule 37 (expr -> let let_list in error .)
    then            reduce using rule 37 (expr -> let let_list in error .)
    loop            reduce using rule 37 (expr -> let let_list in error .)
    cpar            reduce using rule 37 (expr -> let let_list in error .)
    comma           reduce using rule 37 (expr -> let let_list in error .)
    in              reduce using rule 37 (expr -> let let_list in error .)
    else            reduce using rule 37 (expr -> let let_list in error .)
    pool            reduce using rule 37 (expr -> let let_list in error .)
    error           reduce using rule 37 (expr -> let let_list in error .)
    ccur            reduce using rule 37 (expr -> let let_list in error .)
    fi              reduce using rule 37 (expr -> let let_list in error .)


state 181

    (36) expr -> let error in expr .

    semi            reduce using rule 36 (expr -> let error in expr .)
    of              reduce using rule 36 (expr -> let error in expr .)
    then            reduce using rule 36 (expr -> let error in expr .)
    loop            reduce using rule 36 (expr -> let error in expr .)
    cpar            reduce using rule 36 (expr -> let error in expr .)
    comma           reduce using rule 36 (expr -> let error in expr .)
    in              reduce using rule 36 (expr -> let error in expr .)
    else            reduce using rule 36 (expr -> let error in expr .)
    pool            reduce using rule 36 (expr -> let error in expr .)
    error           reduce using rule 36 (expr -> let error in expr .)
    ccur            reduce using rule 36 (expr -> let error in expr .)
    fi              reduce using rule 36 (expr -> let error in expr .)


state 182

    (51) let_list -> let_assign comma let_list .

    in              reduce using rule 51 (let_list -> let_assign comma let_list .)


state 183

    (53) let_assign -> param larrow expr .

    comma           reduce using rule 53 (let_assign -> param larrow expr .)
    in              reduce using rule 53 (let_assign -> param larrow expr .)


state 184

    (38) expr -> case expr of cases_list . esac

    esac            shift and go to state 206


state 185

    (40) expr -> case expr of error . esac
    (57) cases_list -> error . cases_list
    (55) cases_list -> . casep semi
    (56) cases_list -> . casep semi cases_list
    (57) cases_list -> . error cases_list
    (58) casep -> . id colon type rarrow expr

    esac            shift and go to state 207
    error           shift and go to state 188
    id              shift and go to state 187

    cases_list                     shift and go to state 208
    casep                          shift and go to state 186

state 186

    (55) cases_list -> casep . semi
    (56) cases_list -> casep . semi cases_list

    semi            shift and go to state 209


state 187

    (58) casep -> id . colon type rarrow expr

    colon           shift and go to state 210


state 188

    (57) cases_list -> error . cases_list
    (55) cases_list -> . casep semi
    (56) cases_list -> . casep semi cases_list
    (57) cases_list -> . error cases_list
    (58) casep -> . id colon type rarrow expr

    error           shift and go to state 188
    id              shift and go to state 187

    cases_list                     shift and go to state 208
    casep                          shift and go to state 186

state 189

    (39) expr -> case error of cases_list . esac

    esac            shift and go to state 211


state 190

    (41) expr -> if expr then expr . else expr fi
    (44) expr -> if expr then expr . else error fi

    else            shift and go to state 212


state 191

    (43) expr -> if expr then error . else expr fi

    else            shift and go to state 213


state 192

    (42) expr -> if error then expr . else expr fi

    else            shift and go to state 214


state 193

    (45) expr -> while expr loop expr . pool
    (48) expr -> while expr loop expr . error

    pool            shift and go to state 215
    error           shift and go to state 216


state 194

    (47) expr -> while expr loop error . pool

    pool            shift and go to state 217


state 195

    (46) expr -> while error loop expr . pool

    pool            shift and go to state 218


state 196

    (92) func_call -> id opar args cpar .

    arroba          reduce using rule 92 (func_call -> id opar args cpar .)
    dot             reduce using rule 92 (func_call -> id opar args cpar .)
    star            reduce using rule 92 (func_call -> id opar args cpar .)
    div             reduce using rule 92 (func_call -> id opar args cpar .)
    plus            reduce using rule 92 (func_call -> id opar args cpar .)
    minus           reduce using rule 92 (func_call -> id opar args cpar .)
    less            reduce using rule 92 (func_call -> id opar args cpar .)
    lesseq          reduce using rule 92 (func_call -> id opar args cpar .)
    equal           reduce using rule 92 (func_call -> id opar args cpar .)
    semi            reduce using rule 92 (func_call -> id opar args cpar .)
    of              reduce using rule 92 (func_call -> id opar args cpar .)
    then            reduce using rule 92 (func_call -> id opar args cpar .)
    loop            reduce using rule 92 (func_call -> id opar args cpar .)
    cpar            reduce using rule 92 (func_call -> id opar args cpar .)
    comma           reduce using rule 92 (func_call -> id opar args cpar .)
    in              reduce using rule 92 (func_call -> id opar args cpar .)
    else            reduce using rule 92 (func_call -> id opar args cpar .)
    pool            reduce using rule 92 (func_call -> id opar args cpar .)
    error           reduce using rule 92 (func_call -> id opar args cpar .)
    ccur            reduce using rule 92 (func_call -> id opar args cpar .)
    fi              reduce using rule 92 (func_call -> id opar args cpar .)


state 197

    (96) arg_list -> expr comma . arg_list
    (95) arg_list -> . expr
    (96) arg_list -> . expr comma arg_list
    (97) arg_list -> . error arg_list
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 159
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 158
    arg_list                       shift and go to state 219
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 198

    (97) arg_list -> error arg_list .

    cpar            reduce using rule 97 (arg_list -> error arg_list .)


state 199

    (74) base_call -> factor arroba type dot . func_call
    (92) func_call -> . id opar args cpar

    id              shift and go to state 170

    func_call                      shift and go to state 220

state 200

    (89) block -> expr semi block .

    ccur            reduce using rule 89 (block -> expr semi block .)


state 201

    (24) def_func -> error opar formals cpar colon type ocur expr . ccur

    ccur            shift and go to state 221


state 202

    (23) def_func -> id opar formals cpar colon type ocur expr . ccur

    ccur            shift and go to state 222


state 203

    (27) def_func -> id opar formals cpar colon type ocur error . ccur

    ccur            shift and go to state 223


state 204

    (26) def_func -> id opar formals cpar colon error ocur expr . ccur

    ccur            shift and go to state 224


state 205

    (25) def_func -> id opar error cpar colon type ocur expr . ccur

    ccur            shift and go to state 225


state 206

    (38) expr -> case expr of cases_list esac .

    semi            reduce using rule 38 (expr -> case expr of cases_list esac .)
    of              reduce using rule 38 (expr -> case expr of cases_list esac .)
    then            reduce using rule 38 (expr -> case expr of cases_list esac .)
    loop            reduce using rule 38 (expr -> case expr of cases_list esac .)
    cpar            reduce using rule 38 (expr -> case expr of cases_list esac .)
    comma           reduce using rule 38 (expr -> case expr of cases_list esac .)
    in              reduce using rule 38 (expr -> case expr of cases_list esac .)
    else            reduce using rule 38 (expr -> case expr of cases_list esac .)
    pool            reduce using rule 38 (expr -> case expr of cases_list esac .)
    error           reduce using rule 38 (expr -> case expr of cases_list esac .)
    ccur            reduce using rule 38 (expr -> case expr of cases_list esac .)
    fi              reduce using rule 38 (expr -> case expr of cases_list esac .)


state 207

    (40) expr -> case expr of error esac .

    semi            reduce using rule 40 (expr -> case expr of error esac .)
    of              reduce using rule 40 (expr -> case expr of error esac .)
    then            reduce using rule 40 (expr -> case expr of error esac .)
    loop            reduce using rule 40 (expr -> case expr of error esac .)
    cpar            reduce using rule 40 (expr -> case expr of error esac .)
    comma           reduce using rule 40 (expr -> case expr of error esac .)
    in              reduce using rule 40 (expr -> case expr of error esac .)
    else            reduce using rule 40 (expr -> case expr of error esac .)
    pool            reduce using rule 40 (expr -> case expr of error esac .)
    error           reduce using rule 40 (expr -> case expr of error esac .)
    ccur            reduce using rule 40 (expr -> case expr of error esac .)
    fi              reduce using rule 40 (expr -> case expr of error esac .)


state 208

    (57) cases_list -> error cases_list .

    esac            reduce using rule 57 (cases_list -> error cases_list .)


state 209

    (55) cases_list -> casep semi .
    (56) cases_list -> casep semi . cases_list
    (55) cases_list -> . casep semi
    (56) cases_list -> . casep semi cases_list
    (57) cases_list -> . error cases_list
    (58) casep -> . id colon type rarrow expr

    esac            reduce using rule 55 (cases_list -> casep semi .)
    error           shift and go to state 188
    id              shift and go to state 187

    casep                          shift and go to state 186
    cases_list                     shift and go to state 226

state 210

    (58) casep -> id colon . type rarrow expr

    type            shift and go to state 227


state 211

    (39) expr -> case error of cases_list esac .

    semi            reduce using rule 39 (expr -> case error of cases_list esac .)
    of              reduce using rule 39 (expr -> case error of cases_list esac .)
    then            reduce using rule 39 (expr -> case error of cases_list esac .)
    loop            reduce using rule 39 (expr -> case error of cases_list esac .)
    cpar            reduce using rule 39 (expr -> case error of cases_list esac .)
    comma           reduce using rule 39 (expr -> case error of cases_list esac .)
    in              reduce using rule 39 (expr -> case error of cases_list esac .)
    else            reduce using rule 39 (expr -> case error of cases_list esac .)
    pool            reduce using rule 39 (expr -> case error of cases_list esac .)
    error           reduce using rule 39 (expr -> case error of cases_list esac .)
    ccur            reduce using rule 39 (expr -> case error of cases_list esac .)
    fi              reduce using rule 39 (expr -> case error of cases_list esac .)


state 212

    (41) expr -> if expr then expr else . expr fi
    (44) expr -> if expr then expr else . error fi
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    error           shift and go to state 229
    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 228
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 213

    (43) expr -> if expr then error else . expr fi
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 230
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 214

    (42) expr -> if error then expr else . expr fi
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 231
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 215

    (45) expr -> while expr loop expr pool .

    semi            reduce using rule 45 (expr -> while expr loop expr pool .)
    of              reduce using rule 45 (expr -> while expr loop expr pool .)
    then            reduce using rule 45 (expr -> while expr loop expr pool .)
    loop            reduce using rule 45 (expr -> while expr loop expr pool .)
    cpar            reduce using rule 45 (expr -> while expr loop expr pool .)
    comma           reduce using rule 45 (expr -> while expr loop expr pool .)
    in              reduce using rule 45 (expr -> while expr loop expr pool .)
    else            reduce using rule 45 (expr -> while expr loop expr pool .)
    pool            reduce using rule 45 (expr -> while expr loop expr pool .)
    error           reduce using rule 45 (expr -> while expr loop expr pool .)
    ccur            reduce using rule 45 (expr -> while expr loop expr pool .)
    fi              reduce using rule 45 (expr -> while expr loop expr pool .)


state 216

    (48) expr -> while expr loop expr error .

    semi            reduce using rule 48 (expr -> while expr loop expr error .)
    of              reduce using rule 48 (expr -> while expr loop expr error .)
    then            reduce using rule 48 (expr -> while expr loop expr error .)
    loop            reduce using rule 48 (expr -> while expr loop expr error .)
    cpar            reduce using rule 48 (expr -> while expr loop expr error .)
    comma           reduce using rule 48 (expr -> while expr loop expr error .)
    in              reduce using rule 48 (expr -> while expr loop expr error .)
    else            reduce using rule 48 (expr -> while expr loop expr error .)
    pool            reduce using rule 48 (expr -> while expr loop expr error .)
    error           reduce using rule 48 (expr -> while expr loop expr error .)
    ccur            reduce using rule 48 (expr -> while expr loop expr error .)
    fi              reduce using rule 48 (expr -> while expr loop expr error .)


state 217

    (47) expr -> while expr loop error pool .

    semi            reduce using rule 47 (expr -> while expr loop error pool .)
    of              reduce using rule 47 (expr -> while expr loop error pool .)
    then            reduce using rule 47 (expr -> while expr loop error pool .)
    loop            reduce using rule 47 (expr -> while expr loop error pool .)
    cpar            reduce using rule 47 (expr -> while expr loop error pool .)
    comma           reduce using rule 47 (expr -> while expr loop error pool .)
    in              reduce using rule 47 (expr -> while expr loop error pool .)
    else            reduce using rule 47 (expr -> while expr loop error pool .)
    pool            reduce using rule 47 (expr -> while expr loop error pool .)
    error           reduce using rule 47 (expr -> while expr loop error pool .)
    ccur            reduce using rule 47 (expr -> while expr loop error pool .)
    fi              reduce using rule 47 (expr -> while expr loop error pool .)


state 218

    (46) expr -> while error loop expr pool .

    semi            reduce using rule 46 (expr -> while error loop expr pool .)
    of              reduce using rule 46 (expr -> while error loop expr pool .)
    then            reduce using rule 46 (expr -> while error loop expr pool .)
    loop            reduce using rule 46 (expr -> while error loop expr pool .)
    cpar            reduce using rule 46 (expr -> while error loop expr pool .)
    comma           reduce using rule 46 (expr -> while error loop expr pool .)
    in              reduce using rule 46 (expr -> while error loop expr pool .)
    else            reduce using rule 46 (expr -> while error loop expr pool .)
    pool            reduce using rule 46 (expr -> while error loop expr pool .)
    error           reduce using rule 46 (expr -> while error loop expr pool .)
    ccur            reduce using rule 46 (expr -> while error loop expr pool .)
    fi              reduce using rule 46 (expr -> while error loop expr pool .)


state 219

    (96) arg_list -> expr comma arg_list .

    cpar            reduce using rule 96 (arg_list -> expr comma arg_list .)


state 220

    (74) base_call -> factor arroba type dot func_call .

    star            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    div             reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    plus            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    minus           reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    less            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    lesseq          reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    equal           reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    semi            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    of              reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    then            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    loop            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    cpar            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    comma           reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    in              reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    else            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    pool            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    error           reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    ccur            reduce using rule 74 (base_call -> factor arroba type dot func_call .)
    fi              reduce using rule 74 (base_call -> factor arroba type dot func_call .)


state 221

    (24) def_func -> error opar formals cpar colon type ocur expr ccur .

    semi            reduce using rule 24 (def_func -> error opar formals cpar colon type ocur expr ccur .)


state 222

    (23) def_func -> id opar formals cpar colon type ocur expr ccur .

    semi            reduce using rule 23 (def_func -> id opar formals cpar colon type ocur expr ccur .)


state 223

    (27) def_func -> id opar formals cpar colon type ocur error ccur .

    semi            reduce using rule 27 (def_func -> id opar formals cpar colon type ocur error ccur .)


state 224

    (26) def_func -> id opar formals cpar colon error ocur expr ccur .

    semi            reduce using rule 26 (def_func -> id opar formals cpar colon error ocur expr ccur .)


state 225

    (25) def_func -> id opar error cpar colon type ocur expr ccur .

    semi            reduce using rule 25 (def_func -> id opar error cpar colon type ocur expr ccur .)


state 226

    (56) cases_list -> casep semi cases_list .

    esac            reduce using rule 56 (cases_list -> casep semi cases_list .)


state 227

    (58) casep -> id colon type . rarrow expr

    rarrow          shift and go to state 232


state 228

    (41) expr -> if expr then expr else expr . fi

    fi              shift and go to state 233


state 229

    (44) expr -> if expr then expr else error . fi

    fi              shift and go to state 234


state 230

    (43) expr -> if expr then error else expr . fi

    fi              shift and go to state 235


state 231

    (42) expr -> if error then expr else expr . fi

    fi              shift and go to state 236


state 232

    (58) casep -> id colon type rarrow . expr
    (35) expr -> . let let_list in expr
    (36) expr -> . let error in expr
    (37) expr -> . let let_list in error
    (38) expr -> . case expr of cases_list esac
    (39) expr -> . case error of cases_list esac
    (40) expr -> . case expr of error esac
    (41) expr -> . if expr then expr else expr fi
    (42) expr -> . if error then expr else expr fi
    (43) expr -> . if expr then error else expr fi
    (44) expr -> . if expr then expr else error fi
    (45) expr -> . while expr loop expr pool
    (46) expr -> . while error loop expr pool
    (47) expr -> . while expr loop error pool
    (48) expr -> . while expr loop expr error
    (49) expr -> . arith
    (59) arith -> . id larrow expr
    (60) arith -> . not comp
    (61) arith -> . comp
    (62) comp -> . comp less op
    (63) comp -> . comp lesseq op
    (64) comp -> . comp equal op
    (65) comp -> . op
    (66) op -> . op plus term
    (67) op -> . op minus term
    (68) op -> . term
    (69) term -> . term star base_call
    (70) term -> . term div base_call
    (71) term -> . isvoid base_call
    (72) term -> . nox base_call
    (73) term -> . base_call
    (74) base_call -> . factor arroba type dot func_call
    (75) base_call -> . factor
    (76) factor -> . atom
    (77) factor -> . opar expr cpar
    (78) factor -> . factor dot func_call
    (79) factor -> . func_call
    (80) atom -> . num
    (81) atom -> . id
    (82) atom -> . new type
    (83) atom -> . new error
    (84) atom -> . ocur block ccur
    (85) atom -> . true
    (86) atom -> . false
    (87) atom -> . string
    (92) func_call -> . id opar args cpar

    let             shift and go to state 72
    case            shift and go to state 73
    if              shift and go to state 74
    while           shift and go to state 75
    id              shift and go to state 77
    not             shift and go to state 78
    isvoid          shift and go to state 83
    nox             shift and go to state 84
    opar            shift and go to state 88
    num             shift and go to state 89
    new             shift and go to state 90
    ocur            shift and go to state 91
    true            shift and go to state 92
    false           shift and go to state 93
    string          shift and go to state 94

    expr                           shift and go to state 237
    arith                          shift and go to state 76
    comp                           shift and go to state 79
    op                             shift and go to state 80
    term                           shift and go to state 81
    base_call                      shift and go to state 82
    factor                         shift and go to state 85
    func_call                      shift and go to state 86
    atom                           shift and go to state 87

state 233

    (41) expr -> if expr then expr else expr fi .

    semi            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    of              reduce using rule 41 (expr -> if expr then expr else expr fi .)
    then            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    loop            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    cpar            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    comma           reduce using rule 41 (expr -> if expr then expr else expr fi .)
    in              reduce using rule 41 (expr -> if expr then expr else expr fi .)
    else            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    pool            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    error           reduce using rule 41 (expr -> if expr then expr else expr fi .)
    ccur            reduce using rule 41 (expr -> if expr then expr else expr fi .)
    fi              reduce using rule 41 (expr -> if expr then expr else expr fi .)


state 234

    (44) expr -> if expr then expr else error fi .

    semi            reduce using rule 44 (expr -> if expr then expr else error fi .)
    of              reduce using rule 44 (expr -> if expr then expr else error fi .)
    then            reduce using rule 44 (expr -> if expr then expr else error fi .)
    loop            reduce using rule 44 (expr -> if expr then expr else error fi .)
    cpar            reduce using rule 44 (expr -> if expr then expr else error fi .)
    comma           reduce using rule 44 (expr -> if expr then expr else error fi .)
    in              reduce using rule 44 (expr -> if expr then expr else error fi .)
    else            reduce using rule 44 (expr -> if expr then expr else error fi .)
    pool            reduce using rule 44 (expr -> if expr then expr else error fi .)
    error           reduce using rule 44 (expr -> if expr then expr else error fi .)
    ccur            reduce using rule 44 (expr -> if expr then expr else error fi .)
    fi              reduce using rule 44 (expr -> if expr then expr else error fi .)


state 235

    (43) expr -> if expr then error else expr fi .

    semi            reduce using rule 43 (expr -> if expr then error else expr fi .)
    of              reduce using rule 43 (expr -> if expr then error else expr fi .)
    then            reduce using rule 43 (expr -> if expr then error else expr fi .)
    loop            reduce using rule 43 (expr -> if expr then error else expr fi .)
    cpar            reduce using rule 43 (expr -> if expr then error else expr fi .)
    comma           reduce using rule 43 (expr -> if expr then error else expr fi .)
    in              reduce using rule 43 (expr -> if expr then error else expr fi .)
    else            reduce using rule 43 (expr -> if expr then error else expr fi .)
    pool            reduce using rule 43 (expr -> if expr then error else expr fi .)
    error           reduce using rule 43 (expr -> if expr then error else expr fi .)
    ccur            reduce using rule 43 (expr -> if expr then error else expr fi .)
    fi              reduce using rule 43 (expr -> if expr then error else expr fi .)


state 236

    (42) expr -> if error then expr else expr fi .

    semi            reduce using rule 42 (expr -> if error then expr else expr fi .)
    of              reduce using rule 42 (expr -> if error then expr else expr fi .)
    then            reduce using rule 42 (expr -> if error then expr else expr fi .)
    loop            reduce using rule 42 (expr -> if error then expr else expr fi .)
    cpar            reduce using rule 42 (expr -> if error then expr else expr fi .)
    comma           reduce using rule 42 (expr -> if error then expr else expr fi .)
    in              reduce using rule 42 (expr -> if error then expr else expr fi .)
    else            reduce using rule 42 (expr -> if error then expr else expr fi .)
    pool            reduce using rule 42 (expr -> if error then expr else expr fi .)
    error           reduce using rule 42 (expr -> if error then expr else expr fi .)
    ccur            reduce using rule 42 (expr -> if error then expr else expr fi .)
    fi              reduce using rule 42 (expr -> if error then expr else expr fi .)


state 237

    (58) casep -> id colon type rarrow expr .

    semi            reduce using rule 58 (casep -> id colon type rarrow expr .)

